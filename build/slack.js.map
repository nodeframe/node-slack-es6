{"version":3,"sources":["../src/slack.js"],"names":["Slack","cf","globalConfig","webhook_url","username","channel","isDisable","merge","config","data","defaultField","JSON","stringify","url","body","method","headers","_getStringifyData","Promise","resolve","_fetch","service","error","callback","send","text","result"],"mappings":";;;;;;;;;;;;;AAAA;;;;AACA;;;;;;;;;;IAEaA,K,WAAAA,K;AACX,mBAAqB;AAAA,QAATC,EAAS,uEAAJ,EAAI;;AAAA;;AACnB,QAAIC,eAAe;AACjBC,mBAAa,EADI;AAEjBC,gBAAU,EAFO;AAGjBC,eAAS,EAHQ;AAIjBC,iBAAW;AAJM,KAAnB;;AAOA,qBAAEC,KAAF,CAAQL,YAAR,EAAsBD,EAAtB;AACA,SAAKO,MAAL,GAAcN,YAAd;AACD;;;;wCAE4B;AAAA,UAAXO,IAAW,uEAAJ,EAAI;;AAC3B,UAAIC,eAAe;AACjBN,kBAAU,KAAKI,MAAL,CAAYJ,QADL;AAEjBC,iBAAS,KAAKG,MAAL,CAAYH;AAFJ,OAAnB;AAIA,uBAAEE,KAAF,CAAQG,YAAR,EAAsBD,IAAtB;AACA,aAAOE,KAAKC,SAAL,CAAeF,YAAf,CAAP;AACD;;;2BAEMG,G,EAAKC,I,EAAM;AAChB,aAAO,yBAAMD,GAAN,EAAW;AAChBE,gBAAQ,MADQ;AAEhBC,iBAAS;AACP,oBAAU,kBADH;AAEP,0BAAgB;AAFT,SAFO;AAMhBF,cAAM,KAAKG,iBAAL,CAAuBH,IAAvB;AANU,OAAX,CAAP;AAQD;;;2BAEe;AAAA,UAAXL,IAAW,uEAAJ,EAAI;;AACd,UAAG,KAAKD,MAAL,CAAYF,SAAZ,IAAyB,KAAKE,MAAL,CAAYF,SAAZ,KAA0B,MAAtD,EAA8D;AAC5D,eAAOY,QAAQC,OAAR,CAAgB;AACrB,gBAAM,IADe;AAErB,kBAAQ;AAFa,SAAhB,CAAP;AAID;AACD,aAAO,KAAKC,MAAL,CAAY,KAAKZ,MAAL,CAAYL,WAAxB,EAAqCM,IAArC,CAAP;AACD;;;;+EAEqBY,O,EAASC,K,EAAOC,Q;;;;;;;;uBAEb,KAAKC,IAAL,CAAU;AAC7BC,8BAAUJ,OAAV,+BAD6B;AAE7B,iCAAe,CACb;AACE,kCAAaC,KADf;AAEE,6BAAU;AAFZ,mBADa;AAFc,iBAAV,C;;;AAAfI,sB;;AASNH,yBAASG,MAAT;;;;;;;;AAEAH","file":"slack.js","sourcesContent":["import _ from 'lodash'\r\nimport fetch from 'node-fetch'\r\n\r\nexport class Slack {\r\n  constructor(cf = {}) {\r\n    let globalConfig = {\r\n      webhook_url: '',\r\n      username: '',\r\n      channel: '',\r\n      isDisable: false\r\n    }\r\n\r\n    _.merge(globalConfig, cf)\r\n    this.config = globalConfig\r\n  }\r\n\r\n  _getStringifyData(data = {}) {\r\n    let defaultField = {\r\n      username: this.config.username,\r\n      channel: this.config.channel\r\n    }\r\n    _.merge(defaultField, data)\r\n    return JSON.stringify(defaultField)\r\n  }\r\n\r\n  _fetch(url, body) {\r\n    return fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Accept': 'application/json',\r\n        'Content-Type': 'application/json'\r\n      },\r\n      body: this._getStringifyData(body)\r\n    })\r\n  }\r\n\r\n  send(data = {}) {\r\n    if(this.config.isDisable || this.config.isDisable === 'true') {\r\n      return Promise.resolve({\r\n        \"ok\": true,\r\n        \"note\": \"mock the send\"\r\n      })\r\n    }\r\n    return this._fetch(this.config.webhook_url, data)\r\n  }\r\n\r\n  async mongooseOnError(service, error, callback) {\r\n    try {\r\n      const result = await this.send({\r\n        text: `*${service}* MongoDB connection error`,\r\n        \"attachments\": [\r\n          {\r\n            \"title\" : `${error}`,\r\n            \"color\" : \"danger\",\r\n          }\r\n        ]\r\n      })\r\n      callback(result)\r\n    } catch(e) {\r\n      callback(e)\r\n    }\r\n  }\r\n}"]}